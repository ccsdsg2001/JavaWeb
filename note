HTML 标签介绍:1.标签名大小写不敏感。2.标签分为1.基本属性：可以修改简单的样式结果 2.事件属性：可以直接设置事件响应后的代码
标签又分为单标签和双标签
常用标签介绍:
1.<font color显示颜色 face显示字体 size显示大小></font>

2.< 用&lt; >用 &gt; 表示   空格用&nbsp; 表示

3.标题标签:从<h1>到<h6>表示从大到小 align属性表示对齐属性 left左对齐 righe 右对齐 center 其中

4.超链接:在网页中可以点击的链接 <a>超链接
hred属性设置链接地址 target属性设置哪个目标进行跳转 self当前页面 blank新页面

5.列表标签 <ul>无序标签type属性可以修改列表项       <li>列表项 <ol>有序标签

6.img标签:可以在页面上显示图片<img>图片标签
src属性设置图片的路径 width属性设置图片的宽度 height属性设置图片的高度 border属性设置图片边框的大小 alt属性设置当前指定路径找不到图片时,用来替代的文本内容
 绝对路径:http://ip:port/工程名/资源路径 相对路径:.表示当前文件所在的目录 ..表示当前文件所在的上一级目录 文件名 表示当前文件所在目录的文件

7.表格标签:<table>是表格标签
border属性设置表格标签 width属性设置宽度 height属性设置长度 <b>标签是加粗标签 <tr>是行标签 <th>是表头标签 <td>是单元格标签
colsapn 属性设置跨列 rowspan 属性设置跨行

8.iframe标签:可以打开小窗口加载页面.<iframe>标签可以显示一个小页面.
和a标签组合组合使用:1.在iframe标签中使用name属性定义一个名称 2.在a标签的target属性上设置iframe的name的属性值 在<a>中定义target为iframe中的name

9.表单标签:<form>标签 表示一个表单 <input>标签
属性type  text是文本输入框 password为密码输入框 action属性设置提交得服务器地址 method属性设置提交的方式GET或POST  radio为单选框 reset为重置 submit为提交 file为文件上传 hidden为隐藏域(不需要用户参与,但依然发送给服务端) value为显示的文字 name属性可以对其分组 value默认值为一开始显示的内容 checked属性为checked表示默认选中
<Select>标签为下拉列表框 <option>标签为下拉列表框中的选项 selected属性为selected设置默认选中
<textarea>标签为多行文本输入框 rows属性设置显示几行的高度 cols属性设置每行可以显示几个字符宽度
表单提交的时候，数据没有发给服务端三种情况：1.表单没有name属性值 2单选复选（或下拉列表的option标签）都需要添加value属性 3.表单项不在提交的form标签中
GET请求特点：
1.浏览器地址栏中是action属性+请求参数 格式是：name=value&&name=value
2、不安全
3、他有数据长度的限制
POST请求的特点：
1、地址栏中只有action属性值
2.要安全
3.理论上没有数据长度的限制

10.<div>标签 默认独占一行 <span>标签 它的长度是封装数据的长度 <p>标签 默认会在段落上方或下方空出一行

CSS技术
CSS是层叠样式表单,是用于增强网页控制于页面分离的一种技术
语法规则: (选择器)p{
    (属性)font-size:80px(值)
}
选择器:决定受CSS样式影响的HTML元素 属性是你要改变的样式名,并且每个属性都有一个值.使用分号隔开
PS:每行建议只描述一个属性

CSS和HTML的结合方式
<style>标签专门用来定义css样式代码
第一种:在标签的style属性上设置"key:value value;",修改标签样式
第二种:在head标签中,使用style标签定义自己需要的css样式
格式如下:xxx{
    key:value value;
}
第三种:把css样式写成一个单独的css文件,通过link标签引入即可 <link>标签专门用来引入CSS代码

CSS选择器
标签名选择器
格式是:
标签名{
    属性:值;
}
标签名选择器,可以决定那些标签被动的使用这个样式

id选择器
格式是
#id属性值{
    属性:值;
}
id选择器,可以通过id属性选择性的去使用这个样式

class选择器
格式:
.class属性值{
    属性:值;
}
class类型选择性,可以通过class属性有效的选择性去使用这个样式

组合选择器
格式:
选择器1,选择器2,选择器n{
    属性:值
}

常用样式:

JAVAScript介绍
JS是弱类型，JAVA是强类型
弱类型是类型可变，强类型，就是定义变量的时候，类型以确定，而且不可变
特点：1.交互性2.安全性3.跨平台性
JavaScript和html代码的结合方式
第一种方式：只需要在head标签中，或者在body标签中，使用script标签来书写JavaScript代码
<script>标签 alert()是一个警告窗函数,它可以接受任意类型的参数,参数就是警告框的提示信息
第二种方式:使用<script>标签单独引入js src属性专门用来引入js文件路径

JS变量
变量类型:
数值类型:number
字符串类型:string
对象类型:object
布尔类型:Boolean
函数类型:function
特殊的值:undefined 未定义,所有js变量未赋值的时候都是undefined .null 空值 NAN 非数字,非数值

JS中定义的变量格式:
var 变量名;
var 变量名=值;
typeof()是js语言提供的一个函数,可以取变量的数据类型返回

关系运算:
等于:== 等于是简单的做字面值的比较
全等于:=== 除了做字面值的比较,还会比较两个量的数据类型

逻辑运算
且 && 或|| 取反!
在js中,所有的变量,都可以作为一个Boolean类型变量去使用.0,null,undefined,""空串都认为是false
&&且运算,两种情况:1.当表达式全为真的时候,返回最后一个表达式的值.2.当表达式中,有一个为假的时候,返回第一个为假的表达式的值
|| 或运算 两种情况:1.当表达式全为假时,返回最后一个表达式的值 2.只要有一个表达式为真,就返回第一个为真的表达式的值

数组
定义方式:
var 数组名=[];//空数组
var 数组名=[1,'cs',true]//定义数组同时辅助元素
js中的数组,只要我们通过数组下标赋值,那么最大的下标值,就会自动给数组做扩容操作

函数
两种定义方式
1.使用function关键字来定义函数,格式如下
function 函数名(形参列表){
    函数体
}
2.var 函数名 =function(形参列表){函数体}
在js中,定义返回值的函数直接表明return.js中函数不允许重载.会覆盖掉上一次定义
函数的arguments隐形参数(只在function内):在function中函数中不需要定义,可以直接用来获取所有参数的表量,如java中的可变长的参数public void fun(Object...args)
js中的隐形参数是一个数组,操作类型

js中的自定义对象
对象的定义:
var 变量名=new object() //对象实例 空对象
变量名.属性名=值;//定义一个属性
变量名.函数名=function(){}{}//定义一个函数
对象的访问:变量名.属性/函数名(){};
{}花括号形式的自定义对象:var 变量名={属性名:值//定义一个属性,分开  函数名:function(){} //定义一个函数};//空对象
对象的访问:变量名.属性/函数名();

js中的事件
事件是电脑输入设备和页面进行交互的相应
常用的事件:
onload 加载完成事件  页面加载完成之后,常用于做页面js代码初始化操作
onclick 单击事件    常用于按钮的点击相应事件
onblur 失去焦点事件   常用于输入框失去焦点后验证其输入内容是否合法
oncharge 内容发生改变事件 常用下拉框和输入框内容发生改变后操作
onsubmit 表单提交事件  常用于表单提交前,验证所有表单项是否合法

事件注册又分为静态注册和动态注册两种:
当事件相应后,要执行哪些操作代码,叫事件注册或事件绑定
静态注册事件:通过html标签的事件属性直接赋予事件相应后的代码,这种方式叫做静态注册
动态注册事件:先通过js代码得到标签的dom对象,再通过dom对象.事件名=function(){} 这种形式赋予事件响应后的代码,叫动态注册
动态注册基本步骤:1.获取标签对象 2.标签对象.事件名 =function(){}

onload事件
浏览器解析完页面后自动触发的事件
动态注册 window.onload =function(){};  //固定写法

onclick事件 点击
动态注册 window.onload =function(){}
1.获取标签对象 document.getElementById
2.通过标签对象.onclick =function(){}

onblur失去焦点事件
动态注册 window.onload =function(){
1.获取标签对象 var element =document.getElementById
2.通过标签对象.onblur =function(){}
}

oncharge 内容发生改变事件
动态注册 window.onload =function(){
1.获取标签对象 var element =document.getElementById
2.通过标签对象.onchange =function(){}
}

onsubmit事件
静态注册<form action="js.html" method="get" onsubmit="return onsubmtfun()"> return不能少
动态注册 window.onload =function(){
1.获取标签对象 var element =document.getElementById
2.通过标签对象.onsubmit =function(){
            return true/false;}//防止表单不合法
}

DOM模型
把文档中的标签，属性，文本，转换成为对象来管理
DOCUMENT对象
1.Document管理了所有的HTML文档内容
2.是一种树形状的结构
3.把所有标签对象化
4.通过document访问所有的标签对象

1.当要操作一个标签的时候,一定要获取这个标签对象
2.验证字符串符合规则,使用正则表达式技术
3.test()方法测试某个字符串. 匹配返回true 不匹配返回false


DOM对象的三个查询方法
document.getElementById()方法:返回拥有指定ID的第一个对象的引用
document.getElementByName():返回带有指定名称对象的集合,这个集合操作跟数组一样.集合的元素顺序是从上到下的顺序
document.getElementByTagName():按照标签名
PS:如果有ID属性,使用id方法,后Name,再TagName;以上方法,一定在页面加载完成之后,才能查询到标签对象

节点(标签对象)的常用属性和方法
getElementsByTagName():获取当前节点的指定标签名孩子节点
appendChild(oChildNode)方法:添加一个字节点,oChildNode就是添加的孩子节点
属性
childNodes:获取当前节点的所有字节点
firstChild:获取当前节点的第一个子节点
lastChild:获取当前节点的最后一个子节点
parentNode:获取当前节点的父节点
nextSibling:获取当前节点的下一个节点
previousSibling:获取当前节点的上一个节点
className:用于获取或设置标签的class属性值
innerHTML:获取设置起始标签和结束标签中的内容
innerText:表示获取设置起始标签和结束标签中的文本

JQuery(查询)
为按钮添加点击响应函数
$(function (){//相当于window.onload
		var $btnId = $("#btnId");//1.使用jQuery查询到标签对象
		$btnId.click(function (){//2,使用标签对象.click(function(){}
			alert("jquer");
		})

JQuery核心函数
核心函数的4个作用
传入参数为[函数]时：在文档加载完成后执行这个函数
    $(function (){
    })
传入参数为[HTML字符串]时：根据这个字符串创建元素节点对象
    $("<div>\n" +
        "    <span>1</span>\n" +
        "    <span>2</span>\n" +
        "</div>").appendTo("body");
传入参数为[选择器字符串]时：根据这个字符串查找元素节点对象.选择字符串为:1.id属性值时,根据id查询标签对象.2.标签名,根据标签名查找对象,3.类型选择器,根据class属性查询标签对象
    $("button")
传入参数为[DOM对象]时：将DOM对象包装为jQuery对象返回

JQuery对象和DOM对象使用区别
两者都不能使用对方的属性和方法

DOM对象和JQuery对象互转
1.dom对象转化为Jquery对象
(1)先有DOM对象(2)$(DOM对象)可以转换为jquery对象
2.JQuery对象转为dom对象
(1)先有jQuery对象(2)jQuery对象[下标]取出相应的DOM对象

JQuery基础选择器
基本选择器
#ID 根据ID查找标签对象
.class 根据class查找标签对象
element 根据标签名查找标签对象
* 表示任意的,所有的元素
selector1,selector2组合选择器:合并选择器1,选择器2的结果并返回

层级选择器
ancestor descendant 后代选择器 ：在给定的祖先元素下匹配所有的后代元素
parent > child 子元素选择器：在给定的父元素下匹配所有的子元素
prev + next 相邻元素选择器：匹配所有紧接在 prev 元素后的 next 元素
prev ~ sibings 之后的兄弟元素选择器：匹配 prev 元素之后的所有 siblings 元素

过滤选择器
:first 获取第一个元素
:last 获取最后个元素
:not(selector) 去除所有与给定选择器匹配的元素
:even 匹配所有索引值为偶数的元素，从 0 开始计数
:odd 匹配所有索引值为奇数的元素，从 0 开始计数
:eq(index) 匹配一个给定索引值的元素
:gt(index) 匹配所有大于给定索引值的元素
:lt(index) 匹配所有小于给定索引值的元素
:header 匹配如 h1, h2, h3 之类的标题元素
:animated 匹配所有正在执行动画效果的元

内容过滤器
:contains(text) 匹配包含给定文本的元素
:empty 匹配所有不包含子元素或者文本的空元素
:parent 匹配含有子元素或者文本的元素
:has(selector) 匹配含有选择器所匹配的元素的元素

属性过滤器
[attribute] 匹配包含给定属性的元素。
[attribute=value] 匹配给定的属性是某个特定值的元素
[attribute!=value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素。
[attribute^=value] 匹配给定的属性是以某些值开始的元素
[attribute$=value] 匹配给定的属性是以某些值结尾的元素
[attribute*=value] 匹配给定的属性是以包含某些值的元素
[attrSel1][attrSel2][attrSelN] 复合属性选择器，需要同时满足多个条件时使用

表单过滤器
:input 匹配所有 input, textarea, select 和 button 元素
:text 匹配所有 文本输入框
:password 匹配所有的密码输入框
:radio 匹配所有的单选框
:checkbox 匹配所有的复选框
:submit 匹配所有提交按钮
:image 匹配所有 img 标签
:reset 匹配所有重置按钮
:button 匹配所有 input type=button <button>按钮
:file 匹配所有 input type=file 文件上传
:hidden 匹配所有不可见元素 display:none 或 input
:enabled 匹配所有可用元素
:disabled 匹配所有不可用元素
:checked 匹配所有选中的单选，复选，和下拉列表中选中的 option 标签对象
:selected 匹配所有选中的 option

元素的筛选
eq() 获取给定索引的元素 功能跟 :eq() 一样
first() 获取第一个元素 功能跟 :first 一样
last() 获取最后一个元素 功能跟 :last 一样
filter(exp) 留下匹配的元素
is(exp) 判断是否匹配给定的选择器，只要有一个匹配就返回，true
has(exp) 返回包含有匹配选择器的元素的元素 功能跟 :has 一样
not(exp) 删除匹配选择器的元素 功能跟 :not 一样
children(exp) 返回匹配给定选择器的子元素 功能跟 parent>child 一样
find(exp) 返回匹配给定选择器的后代元素 功能跟 ancestor descendant 一样
next() 返回当前元素的下一个兄弟元素 功能跟 prev + next 功能一样
nextAll() 返回当前元素后面所有的兄弟元素 功能跟 prev ~ siblings 功能一样
nextUntil() 返回当前元素到指定匹配的元素为止的后面元素
parent() 返回父元素
prev(exp) 返回当前元素的上一个兄弟元素
prevAll() 返回当前元素前面所有的兄弟元素
prevUnit(exp) 返回当前元素到指定匹配的元素为止的前面元素
siblings(exp) 返回所有兄弟元素
add() 把 add 匹配的选择器的元素添加到当前 jquery

JQuery属性操作 [不传参数是获取,传递参数是设置]
html() 它可以设置和获取起始标签和结束标签中的内容。 跟 dom 属性 innerHTML 一样。
text() 它可以设置和获取起始标签和结束标签中的文本。 跟 dom 属性 innerText 一样。
val() 它可以设置和获取表单项的 value 属性值。 跟 dom 属性 value 一样
attr() 可以设置和获取属性的值,不推荐操作checked,readOnly,selected,disabled等
prop() 可以设置和获取属性的值,只推荐操作checked,readOnly,selected,disabled.

DOM的增删改
内部插入：
appendTo() a.appendTo(b) 把 a 插入到 b 子元素末尾，成为最后一个子元素
prependTo() a.prependTo(b) 把 a 插到 b 所有子元素前面，成为第一个子元素
外部插入：
insertAfter() a.insertAfter(b) 得到 ba
insertBefore() a.insertBefore(b) 得到 ab
替换:
replaceWith() a.replaceWith(b) 用 b 替换掉 a
replaceAll() a.replaceAll(b) 用 a 替换掉所有 b
删除：
remove() a.remove(); 删除 a 标签
empty() a.empty(); 清空 a

CSS样式操作
addClass() 添加样式
removeClass() 删除样式
toggleClass() 有就删除,没有就添加样式
offset() 获取和设置元素的坐标

JQuery动画
基本动画
show() 将隐藏的元素显示
hide() 将可见的元素隐藏
toggle() 可见就隐藏,不可见就显示
以上方法都可以添加参数,第一个参数是动画执行时长,以毫秒为单位.第二个参数是动画的回调函数
fadein() 淡入
fadeout() 淡出
fadeto() 在指定时长内将透明度修改到指定的值
fadeToggle() 淡入/淡出

JQuery事件操作
$( function(){} );
和
window.onload = function(){}
的区别？
他们分别是在什么时候触发？
1、jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好 DOM 对象之后就会马上执行。
2、原生 js 的页面加载完成之后，除了要等浏览器内核解析完标签创建好 DOM 对象，还要等标签显示时需要的内容加载
完成
他们触发的顺序？
1、jQuery 页面加载完成之后先执行
2、原生 js 的页面加载完成之后
他们执行的次数？
1、原生 js 的页面加载完成之后，只会执行最后一次的赋值函数。
2、jQuery 的页面加载完成之后是全部把注册的 function 函数，依次顺序全部执行

jQuery 中其他的事件处理方法：
click() 它可以绑定单击事件，以及触发单击事件
mouseover() 鼠标移入事件
mouseout() 鼠标移出事件
bind() 可以给元素一次性绑定一个或多个事件。
one() 使用上跟 bind 一样。但是 one 方法绑定的事件只会响应一次。
unbind() 跟 bind 方法相反的操作，解除事件的绑定
live() 也是用来绑定事件。它可以用来绑定选择器匹配的所有元素的事件。哪怕这个元素是后面动态创建出
来的也有效


事件的冒泡
什么是事件的冒泡？
事件的冒泡是指，父子元素同时监听同一个事件。当触发子元素的事件的时候，同一个事件也被传递到了父元素的事件里去
响应。
那么如何阻止事件冒泡呢？
在子元素事件函数体内，return false; 可以阻止事件的冒泡传递。
javaScript 事件对象
事件对象，是封装有触发的事件信息的一个 javascript 对象。
我们重点关心的是怎么拿到这个 javascript 的事件对象。以及使用。
如何获取呢 javascript 事件对象呢？
在给元素绑定事件的时候，在事件的 function( event ) 参数列表中添加一个参数，这个参数名，我们习惯取名为 event。
这个 event 就是

XML
XML 是可扩展的标记性语言。
XML的作用
1、用来保存数据，而且这些数据具有自我描述性
2、它还可以做为项目或者模块的配置文件
3、还可以做为网络传输数据的格式（现在 JSON 为主）。

XML语法
1. 文档声明。
2. 元素（标签）
3. xml 属性
4. xml 注释
5. 文本区域（CDATA 区）
dom4j解析技术
 //读取xml文件生成book类
 SAXReader saxReader = new SAXReader();
//通过Document对象获取根元素
Document read = saxReader.read("src/books.xml");
Element rootElement = read.getRootElement();
//通过根元素获取book标签对象
//element和elements通过标签名查找子元素
List<Element> book = rootElement.elements("book");
//遍历,
for(Element book1:book){
    //asxml()把标签对象转为字符串
    Element name = book1.element("name");
    //gettext():可以获取标签中的文本内容
    String text = name.getText();
    //直接获取指定标签中的文本内容
    String price = book1.elementText("price");
    System.out.println(price);

    new book("", "", "", "");
}

JavaWeb
什么是 JavaWeb
JavaWeb 是指，所有通过 Java 语言编写可以通过浏览器访问的程序的总称，叫 JavaWeb。
JavaWeb 是基于请求和响应来开发的。 b)什么是请求
请求是指客户端给服务器发送数据，叫请求 Request。 c)什么是响应
响应是指服务器给客户端回传数据，叫响应 Response。 d)请求和响应的关系
请求和响应是成对出现的，有请求就有响应

Web资源的分类
静态资源:html,css,js,txt,mp4,jpg
动态资源:jsp页面,Servlet程序

常用的web服务器
Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。它是一种轻量级的 javaWeb 容器（服务
器），也是当前应用最广的 JavaWeb 服务器（免费）。
Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）。
GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业服务器，达到产品级质量（应用很少）。
Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持，
性能也比较优良，resin 自身采用 JAVA 语言开发（收费，应用比较多）。
WebLogic：是 Oracle 公司的产品，是目前应用最广泛的 Web 服务器，支持 JavaEE 规范，
而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）。

Tomcat的使用
目录介绍
bin 专门用来存放 Tomcat 服务器的可执行程序
conf 专门用来存放 Tocmat 服务器的配置文件
lib 专门用来存放 Tomcat 服务器的 jar 包
logs 专门用来存放 Tomcat 服务器运行时输出的日记信息
temp 专门用来存放 Tomcdat 运行时产生的临时数据
webapps 专门用来存放部署的 Web 工程。
work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化的目录

Servlet
什么是 Servlet
1、Servlet 是 JavaEE 规范之一。规范就是接口
2、Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器。
3、Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端。

如何实现Servlet
1、编写一个类去实现 Servlet 接口
2、实现 service 方法，处理请求，并响应数据
3、到 web.xml 中去配置

Servlet 的生命周期
1、执行 Servlet 构造器方法
 2、执行 init 初始化方法
 第一、二步，是在第一次访问，的时候创建 Servlet 程序会调用。
 3、执行 service 方法
 第三步，每次访问都会调用。
 4、执行 destroy 销毁方法
 第四步，在 web 工程停止的时候调用。

通过继承 HttpServlet 实现 Servlet 程序
一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。
1、编写一个类去继承 HttpServlet 类
2、根据业务需要重写 doGet 或 doPost 方法
3、到 web.xml 中的配置 Servlet 程序的访问地

ServletConfig类
三大作用
1、可以获取 Servlet 程序的别名 servlet-name 的值
servletConfig.getServletName()
2、获取初始化参数 init-param
servletConfig.getInitParameter("url")
3、获取 ServletContext 对象
servletConfig.getServletContext()

ServerContext类
什么是 ServletContext?
1、ServletContext 是一个接口，它表示 Servlet 上下文对象
2、一个 web 工程，只有一个 ServletContext 对象实例。
3、ServletContext 对象是一个域对象。
4、ServletContext 是在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁。
什么是域对象?
域对象，是可以像 Map 一样存取数据的对象，叫域对象。
这里的域指的是存取数据的操作范围，整个 web 工程。
存数据 取数据 删除 数据
Map put() get() remove()
域对象 setAttribute() getAttribute() removeAttribute();

ServletContext 类的四个作用
1、获取 web.xml 中配置的上下文参数 context-param
2、获取当前的工程路径，格式: /工程路径
3、获取工程部署后在服务器硬盘上的绝对路径
4、像 Map 一样存取数据
getServletConfig().getServletContext();
servletContext.getInitParameter("username");
servletContext.getContextPath();
servletContext.getRealPath("/");

HTTP协议
什么是协议?
协议是指双方，或多方，相互约定好，大家都需要遵守的规则，叫协议。
所谓 HTTP 协议，就是指，客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫 HTTP 协议。
HTTP 协议中的数据又叫报文。 b)请求的 HTTP 协议格式
客户端给服务器发送数据叫请求。
服务器给客户端回传数据叫响应。
请求又分为 GET 请求，和 POST 请求两种
i. GET 请求
1、请求行
(1) 请求的方式 GET
(2) 请求的资源路径[+?+请求参数]
(3) 请求的协议的版本号 HTTP/1.1
2、请求头
key : value 组成 不同的键值对，表示不同的含义
ii. POST 请求
1、请求行
(1) 请求的方式 POST
(2) 请求的资源路径[+?+请求参数]
(3) 请求的协议的版本号 HTTP/1.1
2、请求头
1) key : value 不同的请求头，有不同的含义
空行
3、请求体 ===>>> 就是发送给服务器的数据
iii. 常用请求头的说明
Accept: 表示客户端可以接收的数据类型
Accpet-Languege: 表示客户端可以接收的语言类型
User-Agent: 表示客户端浏览器的信息
Host： 表示请求时的服务器 ip 和端口号

哪些是 GET 请求，哪些是 POST 请求
GET 请求有哪些：
1、form 标签 method=get
2、a 标签
3、link 标签引入 css
4、Script 标签引入 js 文件
5、img 标签引入图片
6、iframe 引入 html 页面
7、在浏览器地址栏中输入地址后敲回车
POST 请求有哪些：
8、form 标签 method=post
c)响应的 HTTP 协议格式
1、响应行
(1) 响应的协议和版本号
(2) 响应状态码
(3) 响应状态描述符
2、响应头
(1) key : value 不同的响应头，有其不同含义
空行
3、响应体 ---->>> 就是回传给客户端的数据

常用的响应码说明
200 表示请求成功
302 表示请求重定向（明天讲）
404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误）
500 表示服务器已经收到请求，但是服务器内部错误（代码错误）

MIME 类型说明
MIME 是 HTTP 协议中数据类型。
MIME 的英文全称是"Multipurpose Internet Mail Extensions" 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型/小
类型”，并与某一种文件的扩展名相对应。
常见的 MIME 类型：
文件 MIME 类型
超文本标记语言文本 .html , .htm text/html
普通文本 .txt text/plain
RTF 文本 .rtf application/rtf
GIF 图形 .gif image/gif
JPEG 图形 .jpeg,.jpg image/jpeg
au 声音文件 .au audio/basic
MIDI 音乐文件 mid,.midi audio/midi,audio/x-midi
RealAudio 音乐文件 .ra, .ram audio/x-pn-realaudio
MPEG 文件 .mpg,.mpeg video/mpeg
AVI 文件 .avi video/x-msvideo
GZIP 文件 .gz application/x-gzip
TAR 文件 .tar application/x-tar

HttpServletRequest类
a)HttpServletRequest 类有什么作用。
每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。
然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的
信息。

b)HttpServletRequest 类的常用方法
i. getRequestURI() 获取请求的资源路径
ii. getRequestURL() 获取请求的统一资源定位符（绝对路径）
iii. getRemoteHost() 获取客户端的 ip 地址
iv. getHeader() 获取请求头
v. getParameter() 获取请求的参数
vi. getParameterValues() 获取请求的参数（多个值的时候使用）
vii. getMethod() 获取请求的方式 GET 或 POST
viii. setAttribute(key, value); 设置域数据
ix. getAttribute(key); 获取域数据
x. getRequestDispatcher() 获取请求转发对象

请求的转发
什么是请求的转发?
请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发
        RequestDispatcher requestDispatcher = req.getRequestDispatcher("/test");
        requestDispatcher.forward(req,resp);

请求转发的特点:
1.浏览器地址栏没有变化
2.他们是一次请求
3.他们可以共享Request域中的数据
4.可以转发到WEB-INF目录下
5.不可以访问工程以外的资源

base标签的作用
Base标签可以设置当前页面中的所有相对路径工作时,参照哪个路径来进行跳转

Web 中的相对路径和绝对路径
在 javaWeb 中，路径分为相对路径和绝对路径两种：
相对路径是：
. 表示当前目录
.. 表示上一级目录
资源名 表示当前目录/资源名
绝对路径：
http://ip:port/工程路径/资源路径
在实际开发中，路径都使用绝对路径，而不简单的使用相对路径。
1、绝对路径
2、base+相对


web 中 / 斜杠的不同意义
在 web 中 / 斜杠 是一种绝对路径。
/ 斜杠 如果被浏览器解析，得到的地址是：http://ip:port/
<a href="/">斜杠</a>
/ 斜杠 如果被服务器解析，得到的地址是：http://ip:port/工程路径
1、<url-pattern>/servlet1</url-pattern>
2、servletContext.getRealPath(“/”);
3、request.getRequestDispatcher(“/”);
特殊情况： response.sendRediect(“/”); 把斜杠发送给浏览器解析。得到 http://ip:port/


HttpServletResponse 类
a)HttpServletResponse 类的作用
HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传
递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息，
我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置
b)两个输出流的说明。
字节流 getOutputStream(); 常用于下载（传递二进制数据）
字符流 getWriter(); 常用于回传字符串（常用）
两个流同时只能使用一个。
使用了字节流，就不能再使用字符流，反之亦然，否则就会报错。

如何往客户端回传数据
PrintWriter writer = resp.getWriter();
writer.write("response's content!!!");

响应的乱码解决
resp.setContentType("text/html;

请求重定向
请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求
重定向（因为之前的地址可能已经被废弃）。
特点:1.浏览器地址会发生变化.
2.两次请求
3.不共享Request域中数据
4.不能访问WEB-INF下的资源
5.可以访问工程外的资源

请求重定向的第一种方案：
// 设置响应状态码 302 ，表示重定向，（已搬迁）
resp.setStatus(302);
// 设置响应头，说明 新的地址在哪里
resp.setHeader("Location", "http://localhost:8080");
请求重定向的第二种方案（推荐使用）：
resp.sendRedirect("http://localhost:8080");

JavaEE三层架构
web层/视图展示层
1.获取请求参数,封装成Bean对象
2.调用Service层处理业务
3.响应数据给客户端,请求转发,重定向
Service业务层
1.处理业务逻辑
2.调用持久层保存到数据库
Dao持久层
1.Dao持久层,只负责跟数据库交互
2.CRUD 操作

JSP
1.什么是 jsp，它有什么用?
jsp 的全换是 java server pages。Java 的服务器页面。
jsp 的主要作用是代替 Servlet 程序回传 html 页面的数据。
因为 Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高

2、jsp 如何访问：
jsp 页面和 html 页面一样，都是存放在 web 目录下。访问也跟访问 html 页面一样。
比如：
在 web 目录下有如下的文件：
web 目录
a.html 页面 访问地址是 =======>>>>>> http://ip:port/工程路径/a.html
b.jsp 页面 访问地址是 =======>>>>>> http://ip:port/工程路径/b.jsp

jsp 的本质是什么。
jsp 页面本质上是一个 Servlet 程序。
当我们第一次访问 jsp 页面的时候。Tomcat 服务器会帮我们把 jsp 页面翻译成为一个 java 源文件。并且对它进行编译成
为.class 字节码程序.jsp 就是 Servlet 程序
其底层实现，也是通过输出流。把 html 页面数据回传给客户端

jsp 的三种语法
jsp 头部的 page 指令
jsp 的 page 指令可以修改 jsp 页面中一些重要的属性，或者行为。
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
i. language 属性 表示 jsp 翻译后是什么语言文件。暂时只支持 java。
ii. contentType 属性 表示 jsp 返回的数据类型是什么。也是源码中 response.setContentType()参数值
iii. pageEncoding 属性 表示当前 jsp 页面文件本身的字符集。
iv. import 属性 跟 java 源代码中一样。用于导包，导类。
========================两个属性是给 out 输出流使用=============================
v. autoFlush 属性 设置当 out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是 true。
vi. buffer 属性 设置 out 缓冲区的大小。默认是 8kb
缓冲区溢出错误：
========================两个属性是给 out 输出流使用=============================
vii. errorPage 属性 设置当 jsp 页面运行时出错，自动跳转去的错误页面路径。
<!--
errorPage 表示错误后自动跳转去的路径 <br/>
这个路径一般都是以斜杠打头，它表示请求地址为 http://ip:port/工程路径/
映射到代码的 Web 目录
-->
viii. isErrorPage 属性 设置当前 jsp 页面是否是错误信息页面。默认是 false。如果是 true 可以
获取异常信息。
ix. session 属性 设置访问当前 jsp 页面，是否会创建 HttpSession 对象。默认是 true。
x. extends 属性 设置 jsp 翻译出来的 java 类默认继承谁

jsp 中的常用脚本
i. 声明脚本(极少使用)
声明脚本的格式是： <%! 声明 java 代码 %>
作用：可以给 jsp 翻译出来的 java 类定义属性和方法甚至是静态代码块。内部类等

ii. 表达式脚本（常用）
表达式脚本的格式是：<%=表达式%>
表达式脚本的作用是：的 jsp 页面上输出数据。
表达式脚本的特点：
1、所有的表达式脚本都会被翻译到_jspService() 方法中
2、表达式脚本都会被翻译成为 out.print()输出到页面上
3、由于表达式脚本翻译的内容都在_jspService() 方法中,所以_jspService()方法中的对象都可以直接使用。
4、表达式脚本中的表达式不能以分号结束。

iii. 代码脚本
代码脚本的格式是：
<%
java 语句
%>
代码脚本的作用是：可以在 jsp 页面中，编写我们自己需要的功能（写的是 java 语句）。
代码脚本的特点是：
1、代码脚本翻译之后都在_jspService 方法中
2、代码脚本由于翻译到_jspService()方法中，所以在_jspService()方法中的现有对象都可以直接使用。
3、还可以由多个代码脚本块组合完成一个完整的 java 语句。
4、代码脚本还可以和表达式脚本一起组合使用，在 jsp 页面上输出数据

jsp 中的三种注释
i. html 注释
<!-- 这是 html 注释 -->
html 注释会被翻译到 java 源代码中。在_jspService 方法里，以 out.writer 输出到客户端。

ii. java 注释
<%
// 单行 java 注释
/* 多行 java 注释 */
%>
java 注释会被翻译到 java 源代码中。

iii. jsp 注释
<%-- 这是 jsp 注释 --%>
jsp 注释可以注掉，jsp 页面中所有代码。

jsp 九大内置对象
jsp 中的内置对象，是指 Tomcat 在翻译 jsp 页面成为 Servlet 源代码后，内部提供的九大对象，叫内置对象。
request 请求对象
response 响应对象
pageContext jsp的上下文对象
session 会话对象
application ServletContext对象
config ServletConfig对象
out jsp输出流对象
page 指向当前的jsp的对象
exception 异常对象

jsp 四大域对象
四个域对象分别是：
pageContext (PageContextImpl 类) 当前 jsp 页面范围内有效
request (HttpServletRequest 类)、 一次请求内有效
session (HttpSession 类)、 一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器）
application (ServletContext 类) 整个 web 工程范围内都有效（只要 web 工程不停止，数据都在）
域对象是可以像 Map 一样存取数据的对象。四个域对象功能一样。不同的是它们对数据的存取范围。
虽然四个域对象都可以存取数据。在使用上它们是有优先顺序的。
四个域在使用的时候，优先顺序分别是，他们从小到大的范围的顺序。
pageContext ====>>> request ====>>> session ====>>> application

jsp 中的 out 输出和 response.getWriter 输出的区别
response 中表示响应，我们经常用于设置返回给客户端的内容（输出）
out 也是给用户做输出使用的
当JSP页面中所有代码执行完成后会做以下两个操作:
1.执行out.flush()操作,会把out缓冲区中的数据追加写入到response缓冲区末尾
2.会执行response的刷新操作,把全部数据写给客户端
由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 out 来进行输出。避
免打乱页面输出内容的顺序。
out.write() 输出字符串没有问题
out.print() 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出）
深入源码，浅出结论：在 jsp 页面中，可以统一使用 out.print()来进行输出

jsp 的常用标签
a)jsp 静态包含
示例说明：
<%--
<%@ include file=""%> 就是静态包含
file 属性指定你要包含的 jsp 页面的路径
地址中第一个斜杠 / 表示为 http://ip:port/工程路径/ 映射到代码的 web 目录
静态包含的特点：
1、静态包含不会翻译被包含的 jsp 页面。
2、静态包含其实是把被包含的 jsp 页面的代码拷贝到包含的位置执行输出。
--%>
<%@ include file="/include/footer.jsp"%>

b)jsp 动态包含
示例说明：
<%--
<jsp:include page=""></jsp:include> 这是动态包含
page 属性是指定你要包含的 jsp 页面的路径
动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置
动态包含的特点：
1、动态包含会把包含的 jsp 页面也翻译成为 java 代码
2、动态包含底层代码使用如下代码去调用被包含的 jsp 页面执行输出。
JspRuntimeLibrary.include(request, response, "/include/footer.jsp", out, false);
3、动态包含，还可以传递参数
--%>
<jsp:include page="/include/footer.jsp">
<jsp:param name="username" value="bbj"/>
<jsp:param name="password" value="root"/>
</jsp:include>

c)jsp 标签-转发
示例说明：
<%--
<jsp:forward page=""></jsp:forward> 是请求转发标签，它的功能就是请求转发
page 属性设置请求转发的路径
--%>
<jsp:forward page="/scope2.jsp"></jsp:forward>

Listerner监听器
什么是 Listener 监听器？
1、Listener 监听器它是 JavaWeb 的三大组件之一。JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监
听器。
2、Listener 它是 JavaEE 的规范，就是接口
3、监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。

ServletContextListener 监听器
ServletContextListener 它可以监听 ServletContext 对象的创建和销毁。
ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。
监听到创建和销毁之后都会分别调用 ServletContextListener 监听器的方法反馈。
两个方法分别是：
public interface ServletContextListener extends EventListener {
/**
* 在 ServletContext 对象创建之后马上调用，做初始化
*/
public void contextInitialized(ServletContextEvent sce);
/**
* 在 ServletContext 对象销毁之后调用
*/
public void contextDestroyed(ServletContextEvent sce);
}

如何使用 ServletContextListener 监听器监听 ServletContext 对象。
使用步骤如下：
1、编写一个类去实现 ServletContextListener
2、实现其两个回调方法
3、到 web.xml 中去配置监听器

web.xml 中的配置：
<!--配置监听器-->
<listener>
<listener-class>com.atguigu.listener.MyServletContextListenerImpl</listener-class>
</listener>

EL表达式
什么是 EL 表达式，EL 表达式的作用?
EL 表达式的全称是：Expression Language。是表达式语言。
EL 表达式的什么作用：EL 表达式主要是代替 jsp 页面中的表达式脚本在 jsp 页面中进行数据的输出。
因为 EL 表达式在输出数据的时候，要比 jsp 的表达式脚本要简洁很多。
<body>
<%
request.setAttribute("key","值");
%>
表达式脚本输出 key 的值是：
<%=request.getAttribute("key1")==null?"":request.getAttribute("key1")%><br/>
EL 表达式输出 key 的值是：${key1}
</body>
EL 表达式的格式是：${表达式}
EL 表达式在输出 null 值的时候，输出的是空串。jsp 表达式脚本输出 null 值的时候，输出的是 null 字符串。

EL 表达式搜索域数据的顺序
EL 表达式主要是在 jsp 页面中输出数据。
主要是输出域对象中的数据。
当四个域中都有相同的 key 的数据的时候，EL 表达式会按照四个域的从小到大的顺序去进行搜索，找到就输出。
<body>
<%
//往四个域中都保存了相同的 key 的数据。
request.setAttribute("key", "request");
session.setAttribute("key", "session");
application.setAttribute("key", "application");
pageContext.setAttribute("key", "pageContext");
%>
${ key }
</body>

EL 表达式输出 Bean 的普通属性，数组属性。List 集
合属性，map 集合属性
i. 需求——输出 Person 类中普通属性，数组属性。list 集合属性和 map 集合属性
输出 Person：${ p }<br/>
输出 Person 的 name 属性：${p.name} <br>
输出 Person 的 pnones 数组属性值：${p.phones[2]} <br>
输出 Person 的 cities 集合中的元素值：${p.cities} <br>
输出 Person 的 List 集合中个别元素值：${p.cities[2]} <br>
输出 Person 的 Map 集合: ${p.map} <br>
输出 Person 的 Map 集合中某个 key 的值: ${p.map.key3} <br>
输出 Person 的 age 属性：${p.age} <br

EL 表达式——运算
语法：${ 运算表达式 } ， EL 表达式支持如下:
1）关系运算
关系运算符 说 明 范 例 结果
== 或 eq 等于 ${ 5 == 5 } 或 ${ 5 eq 5 } true
!= 或 ne 不等于 ${ 5 !=5 } 或 ${ 5 ne 5 } false
< 或 lt 小于 ${ 3 < 5 } 或 ${ 3 lt 5 } true
> 或 gt 大于 ${ 2 > 10 } 或 ${ 2 gt 10 } false
<= 或 le 小于等于 ${ 5 <= 12 } 或 ${ 5 le 12 } true
>= 或 ge 大于等于 ${ 3 >= 5 } 或 ${ 3 ge 5 } false

2）逻辑运算
逻辑运算符 说 明 范 例 结果
&& 或 and 与运算 ${ 12 == 12 && 12 < 11 } 或 ${ 12 == 12 and 12 < 11 } false
|| 或 or 或运算 ${ 12 == 12 || 12 < 11 } 或 ${ 12 == 12 or 12 < 11 } true
! 或 not 取反运算 ${ !true } 或 ${not true } false

3）算数运算
算数运算符 说 明 范 例 结果
+ 加法 ${ 12 + 18 } 30
- 减法 ${ 18 - 8 } 10
* 乘法 ${ 12 * 12 } 144
/ 或 div 除法 ${ 144 / 12 } 或 ${ 144 div 12 } 12
% 或 mod 取模 ${ 144 % 10 } 或 ${ 144 mod 10 } 4

i. empty 运算
empty 运算可以判断一个数据是否为空，如果为空，则输出 true,不为空输出 false。
以下几种情况为空：
1、值为 null 值的时候，为空
2、值为空串的时候，为空
3、值是 Object 类型数组，长度为零的时候
4、list 集合，元素个数为零
5、map 集合，元素个数为零
{ empty emptyNull } <br/>
${ empty emptyStr } <br/>
${ empty emptyArr } <br/>
${ empty emptyList } <br/>
${ empty  emptyMap } <br/>

三元运算
表达式 1？表达式 2：表达式 3
如果表达式 1 的值为真，返回表达式 2 的值，如果表达式 1 的值为假，返回表达式 3 的值

“.”点运算 和 [] 中括号运算符
.点运算，可以输出 Bean 对象中某个属性的值。
[]中括号运算，可以输出有序集合中某个元素的值。
并且[]中括号运算，还可以输出 map 集合中 key 里含有特殊字符的 key 的值
${ map['a.a.a'] } <br>
${ map["b+b+b"] } <br>
${ map['c-c-c'] } <b

EL 表达式的 11 个隐含对象
EL 个达式中 11 个隐含对象，是 EL 表达式中自己定义的，可以直接使用。
变量 类型 作用
pageContext PageContextImpl 它可以获取 jsp 中的九大内置对象
pageScope Map<String,Object> 它可以获取 pageContext 域中的数据
requestScope Map<String,Object> 它可以获取 Request 域中的数据
sessionScope Map<String,Object> 它可以获取 Session 域中的数据
applicationScope Map<String,Object> 它可以获取 ServletContext 域中的数据
param Map<String,String> 它可以获取请求参数的值
paramValues Map<String,String[]> 它也可以获取请求参数的值，获取多个值的时候使用。
header Map<String,String> 它可以获取请求头的信息
headerValues Map<String,String[]> 它可以获取请求头的信息，它可以获取多个值的情况
cookie Map<String,Cookie> 它可以获取当前请求的 Cookie 信息
initParam Map<String,String> 它可以获取在 web.xml 中配置的<context-param>上下文参数

i. EL 获取四个特定域中的属性
pageScope ====== pageContext 域
requestScope ====== Request 域
sessionScope ====== Session 域
applicationScope ====== ServletContext

pageContext 对象的使用
1.协议： ${ req.scheme }<br>
2.服务器 ip：${ pageContext.request.serverName }<br>
3.服务器端口：${ pageContext.request.serverPort }<br>
4.获取工程路径：${ pageContext.request.contextPath }<br>
5.获取请求方法：${ pageContext.request.method }<br>
6.获取客户端 ip 地址：${ pageContext.request.remoteHost }<br>
7.获取会话的 id 编号：${ pageContext.session.id }<br>

EL 表达式其他隐含对象的使用
param Map<String,String> 它可以获取请求参数的值
paramValues Map<String,String[]> 它也可以获取请求参数的值，获取多个值的时候使用。
输出请求参数 username 的值：${ param.username } <br>
输出请求参数 password 的值：${ param.password } <br>
输出请求参数 username 的值：${ paramValues.username[0] } <br>
输出请求参数 hobby 的值：${ paramValues.hobby[0] } <br>
输出请求参数 hobby 的值：${ paramValues.hobby[1] } <br

header Map<String,String> 它可以获取请求头的信息
headerValues Map<String,String[]> 它可以获取请求头的信息，它可以获取多个值的情况
输出请求头【User-Agent】的值：${ header['User-Agent'] } <br>
输出请求头【Connection】的值：${ header.Connection } <br>
输出请求头【User-Agent】的值：${ headerValues['User-Agent'][0] } <br>

cookie Map<String,Cookie> 它可以获取当前请求的 Cookie 信息
 Cookie 的名称：${ cookie.JSESSIONID.name } <br>
获取 Cookie 的值：${ cookie.JSESSIONID.value } <br>

initParam Map<String,String> 它可以获取在 web.xml 中配置的<context-param>上下文参数
输出&lt;Context-param&gt;username 的值：${ initParam.username } <br>
输出&lt;Context-param&gt;url 的值：${ initParam.url } <br>

JSTL 标签库
JSTL 标签库 全称是指 JSP Standard Tag Library JSP 标准标签库。是一个不断完善的开放源代码的 JSP 标
签库。
EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个 jsp 页面
变得更佳简洁

JSTL 由五个不同功能的标签库组成。
核心标签库--重点 http://java.sun.com/jsp/jstl/core  c
格式化 http://java.sun.com/jsp/jstl/fmt      fmt
函数 http://java.sun.com/jsp/jstl/functions    fn
数据库(不使用) http://java.sun.com/jsp/jstl/sql    sql
XML(不使用) http://java.sun.com/jsp/jstl/xml     x

在 jsp 标签库中使用 taglib 指令引入标签库
CORE 标签库
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
XML 标签库
<%@ taglib prefix="x" uri="http://java.sun.com/jsp/jstl/xml" %>
FMT 标签库
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
SQL 标签库
<%@ taglib prefix="sql" uri="http://java.sun.com/jsp/jstl/sql" %>
FUNCTIONS 标签库
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %

JSTL 标签库的使用步骤
1、先导入 jstl 标签库的 jar 包。
taglibs-standard-impl-1.2.1.jar
taglibs-standard-spec-1.2.1.jar
2、第二步，使用 taglib 指令引入标签库。
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %

core 核心库使用
i. <c:set />（使用很少）
作用：set 标签可以往域中保存数据
i.<c:set />
作用：set 标签可以往域中保存数据
域对象.setAttribute(key,value);
scope 属性设置保存到哪个域
page 表示 PageContext 域（默认值）
request 表示 Request 域
session 表示 Session 域
application 表示 ServletContext 域
var 属性设置 key 是多少
value 属性设置值
实例:
${ sessionScope.abc } <br>
<c:set scope="session" var="abc" value="abcValue"/>
保存之后：${ sessionScope.abc } <br

ii. <c:if />
if 标签用来做 if 判断。
if 标签用来做 if 判断。
test 属性表示判断的条件（使用 EL 表达式输出）
实例:
<c:if test="${ 12 == 12 }">
<h1>12 等于 12</h1>
</c:if>
<c:if test="${ 12 != 12 }">
<h1>12 不等于 12</h1>
</c:if

iii. <c:choose> <c:when> <c:otherwise>标签
作用：多路判断。跟 switch ... case
作用：多路判断。跟 switch ... case .... default 非常接近
choose 标签开始选择判断
when 标签表示每一种判断情况
test 属性表示当前这种判断情况的值
otherwise 标签表示剩下的情况
<c:choose> <c:when> <c:otherwise>标签使用时需要注意的点：
1、标签里不能使用 html 注释，要使用 jsp 注释
2、when 标签的父标签一定要是 choose 标签
实例:<%
   request.setAttribute("height", 180);
   %>
   <c:choose>
   <%-- 这是 html 注释 --%>
   <c:when test="${ requestScope.height > 190 }">
   <h2>小巨人</h2>
   </c:when>
   <c:when test="${ requestScope.height > 180 }">
   <h2>很高</h2>
   </c:when>
   <c:when test="${ requestScope.height > 170 }">
   <h2>还可以</h2>
   </c:when>
   <c:otherwise>
   <c:choose>
   <c:when test="${requestScope.height > 160}">
   <h3>大于 160</h3>
   </c:when>
   <c:when test="${requestScope.height > 150}">
   <h3>大于 150</h3>
   </c:when>
   <c:when test="${requestScope.height > 140}">
   <h3>大于 140</h3>
   </c:when>
   <c:otherwise>
   其他小于 140
   </c:otherwise>
   </c:choose>
   </c:otherwise>
   </c:choose>

 <c:forEach />标签
 作用：遍历输出使用.begin 属性设置开始的索引
           end 属性设置结束的索引
           var 属性表示循环的变量(也是当前正在遍历到的数据)
           for (int i =
实例:1. 遍历 1 到 10，输出
<table border="1">
   <c:forEach begin="1" end="10" var="i">
   <tr>
   <td>第${i}行</td>
   </tr>
   </c:forEach>
   </table

2. 遍历 Object 数组
for (Object item: arr)
items 表示遍历的数据源（遍历的集合）
var 表示当前遍历到的数
实例:<%
   request.setAttribute("arr", new String[]{"18610541354","18688886666","18699998888"});
   %>
   <c:forEach items="${ requestScope.arr }" var="item">
   ${ item } <br>
   </c:forEach

3. 遍历 Map 集合
实例:<%
   Map<String,Object> map = new HashMap<String, Object>();
   map.put("key1", "value1");
   map.put("key2", "value2");
   map.put("key3", "value3");
   // for ( Map.Entry<String,Object> entry : map.entrySet()) {
   // }
   request.setAttribute("map", map);
   %>
   <c:forEach items="${ requestScope.map }" var="entry">
   <h1>${entry.key} = ${entry.value}</h1>
   </c:forEach>

4. 遍历 List 集合---list 中存放 Student 类，有属性：编号，用户名，密码，年龄，
电话信息

文件的上传和下载
文件的上传介绍
1、要有一个 form 标签，method=post 请求
2、form 标签的 encType 属性值必须为 multipart/form-data 值
3、在 form 标签中使用 input type=file 添加上传的文件
4、编写服务器代码（Servlet 程序）接收，处理上传的数据。
encType=multipart/form-data 表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼
接，然后以二进制流的形式发送给服务器

commons-fileupload.jar 常用 API
ommons-fileupload.jar 需要依赖 commons-io.jar 这个包，所以两个包我们都要引入。
第一步，就是需要导入两个 jar 包：
commons-fileupload-1.2.1.jar
commons-io-1.4.jar
commons-fileupload.jar 和 commons-io.jar 包中，我们常用的类有哪些？
ServletFileUpload 类，用于解析上传的数据。
FileItem 类，表示每一个表单项。
boolean ServletFileUpload.isMultipartContent(HttpServletRequest request);
判断当前上传的数据格式是否是多段的格式。
public List<FileItem> parseRequest(HttpServletRequest request)
解析上传的数据
boolean FileItem.isFormField()
判断当前这个表单项，是否是普通的表单项。还是上传的文件类型。
true 表示普通类型的表单项
false 表示上传的文件类型
String FileItem.getFieldName()
获取表单项的 name 属性值
String FileItem.getString()
获取当前表单项的值。
String FileItem.getName();
获取上传的文件名
void FileItem.write( file );
将上传的文件写到 参数 file

fileupload 类库的使用：
实例:
上传文件的表单：
<form action="http://192.168.31.74:8080/09_EL_JSTL/uploadServlet" method="post"
enctype="multipart/form-data">
用户名：<input type="text" name="username" /> <br>
头像：<input type="file" name="photo" > <br>
<input type="submit" value="上传">
</form>

解析上传的数据的代码
protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException,IOException {
//1 先判断上传的数据是否多段数据（只有是多段的数据，才是文件上传的）
if (ServletFileUpload.isMultipartContent(req)) {
// 创建 FileItemFactory 工厂实现类
FileItemFactory fileItemFactory = new DiskFileItemFactory();
// 创建用于解析上传数据的工具类 ServletFileUpload 类
ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory);
try {
// 解析上传的数据，得到每一个表单项 FileItem
List<FileItem> list = servletFileUpload.parseRequest(req);
// 循环判断，每一个表单项，是普通类型，还是上传的文件
for (FileItem fileItem : list) {
if (fileItem.isFormField()) {
// 普通表单项
System.out.println("表单项的 name 属性值：" + fileItem.getFieldName());
// 参数 UTF-8.解决乱码问题
System.out.println("表单项的 value 属性值：" + fileItem.getString("UTF-8"));
} else {
// 上传的文件
System.out.println("表单项的 name 属性值：" + fileItem.getFieldName());
System.out.println("上传的文件名：" + fileItem.getName());
fileItem.write(new File("e:\\" + fileItem.getName()));

文件下载
下载的常用 API 说明：
response.getOutputStream();
servletContext.getResourceAsStream();
servletContext.getMimeType();
response.setContentType();
response.setHeader("Content-Disposition", "attachment; fileName=1.jpg");
这个响应头告诉浏览器。这是需要下载的。而 attachment 表示附件，也就是下载的一个文件。fileName=后面，
表示下载的文件名

文件下载实例:
1、获取要下载的文件名
String downloadFileName = "2.jpg";
// 2、读取要下载的文件内容 (通过 ServletContext 对象可以读取)
ServletContext servletContext = getServletContext();
// 获取要下载的文件类型
String mimeType = servletContext.getMimeType("/file/" + downloadFileName);
System.out.println("下载的文件类型：" + mimeType);
// 4、在回传前，通过响应头告诉客户端返回的数据类型
resp.setContentType(mimeType);
// 5、还要告诉客户端收到的数据是用于下载使用（还是使用响应头）
// Content-Disposition 响应头，表示收到的数据怎么处理
// attachment 表示附件，表示下载使用
// filename= 表示指定下载的文件名
resp.setHeader("Content-Disposition", "attachment; filename=" + downloadFileName);
/**
* /斜杠被服务器解析表示地址为 http://ip:prot/工程名/ 映射 到代码的 Web 目录
*/
InputStream resourceAsStream = servletContext.getResourceAsStream("/file/" +
downloadFileName);
// 获取响应的输出流
OutputStream outputStream = resp.getOutputStream();
// 3、把下载的文件内容回传给客户端
// 读取输入流中全部的数据，复制给输出流，输出给客户端
IOUtils.copy(resourceAsStream,outputStream);

附件中文名乱码问题解决方案：
方案一：URLEncoder 解决 IE 和谷歌浏览器的 附件中
文名问题。
如果客户端浏览器是 IE 浏览器 或者 是谷歌浏览器。我们需要使用 URLEncoder 类先对中文名进行 UTF-8 的编码
操作。
因为 IE 浏览器和谷歌浏览器收到含有编码后的字符串后会以 UTF-8 字符集进行解码显示。
// 把中文名进行 UTF-8 编码操作。
String str = "attachment; fileName=" + URLEncoder.encode("中文.jpg", "UTF-8");
// 然后把编码后的字符串设置到响应头中
response.setHeader("Content-Disposition", str);

方案二：BASE64 编解码 解决 火狐浏览器的附件中文名问题
如果客户端浏览器是火狐浏览器。 那么我们需要对中文名进行 BASE64 的编码操作。
这时候需要把请求头 Content-Disposition: attachment; filename=中文名
编码成为：Content-Disposition: attachment; filename==?charset?B?xxxxx?=
=?charset?B?xxxxx?= 现在我们对这段内容进行一下说明。
=? 表示编码内容的开始
charset 表示字符集
B 表示 BASE64 编码
xxxx 表示文件名 BASE64 编码后的内容
?= 表示编码内容的结束
BASE64 编解码操作：
public static void main(String[] args) throws Exception {
String content = "这是需要 Base64 编码的内容";
// 创建一个 Base64 编码器
BASE64Encoder base64Encoder = new BASE64Encoder();
// 执行 Base64 编码操作
String encodedString = base64Encoder.encode(content.getBytes("UTF-8"));
System.out.println( encodedString );
// 创建 Base64 解码器
BASE64Decoder base64Decoder = new BASE64Decoder();
// 解码操作
byte[] bytes = base64Decoder.decodeBuffer(encodedString);
String str = new String(bytes, "UTF-8");
System.out.println(str);
}
因为火狐使用的是 BASE64 的编解码方式还原响应中的汉字。所以需要使用 BASE64Encoder 类进行编码操作。
// 使用下面的格式进行 BASE64 编码后
String str = "attachment; fileName=" + "=?utf-8?B?"
+ new BASE64Encoder().encode("中文.jpg".getBytes("utf-8")) + "?=";
// 设置到响应头中
response.setHeader("Content-Disposition", str);
那么我们如何解决上面两种不同编解码方式呢。我们只需要通过判断请求头中 User-Agent 这个请求头携带过来的
浏览器信息即可判断出是什么浏览器。
如下：
String ua = request.getHeader("User-Agent");
// 判断是否是火狐浏览器
if (ua.contains("Firefox")) {
// 使用下面的格式进行 BASE64 编码后
String str = "attachment; fileName=" + "=?utf-8?B?"
+ new BASE64Encoder().encode("中文.jpg".getBytes("utf-8")) + "?=";
// 设置到响应头中
response.setHeader("Content-Disposition", str);
} else {
// 把中文名进行 UTF-8 编码操作。
String str = "attachment; fileName=" + URLEncoder.encode("中文.jpg", "UTF-8");
// 然后把编码后的字符串设置到响应头中
response.setHeader("Content-Disposition", str)



p244
















